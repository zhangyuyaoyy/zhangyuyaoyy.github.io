# JVM


本内容根据B站[黑马程序员JVM完整教程](https://www.bilibili.com/video/BV1yE411Z7AP)整理记录。

<!--more-->

## JVM

![avator](/images/jvm/JVM组成.png)

## 内存结构

![avator](/images/jvm/内存结构.png)

### 程序计数器

程序计数器通过寄存器实现

作用：记录下一条JVM指令执行的地址

特点：

- 线程私有
- 不会线程溢出

### 虚拟机栈

#### 定义

- 栈：线程运行时需要的内存空间。
- 栈帧：方法运行时需要的内存空间。
- 每个栈由多个栈帧组成，对应着每次方法调用时所占用的内存。
- 每个线程只能有一个活动栈帧，对应这当前正在执行的那个方法。

#### 问题辨析

1. GC是否会回收栈内存？
   - GC只会回收堆内存里的对象。
2. 栈内存是否越大越好？
   - 分配太大会导致线程数量减少。
3. 方法内的局部变量是否是线程安全？
   - 如果方法内变量没有逃离方法的作用范围，它就是线程安全的。

#### 栈内存溢出

通过-Xss设置栈内存，默认1024k。

1. 栈帧过多；
2. 栈帧过大。

#### 线程诊断

1. CPU占用过多
   - 定位：
     - top定位进程；
     - ps H -ep pid, tid, %cpu | grep pid 定位线程；
     - jstack pid。
2. 程序长时间没有输出结果
   - jstack pid

### 本地方法栈

#### 定义

- 为本地方法提供内存空间

### 堆

#### 定义

- 通过new关键字创建的对象，都会使用堆内存

#### 堆内存溢出

- 不断创建新对象，同时旧对象一直不被回收。
- 通过-Xms设置堆内存大小

#### 堆内存诊断

1. jps工具

   - 查看当前系统中有哪些java进程

2. jmap工具

   - 查看堆内存占用情况

   - jmap -heap pid

3. jconsole、jvisualjvm

   - 图形化界面，多功能监测工具，可以连续监测。

#### 特点

- 是线程共享的，堆中对象都需要考虑线程安全的问题
- 有垃圾回收机制

### 方法区

#### 方法区内存溢出

- 1.8以前会导致永久代内存溢出，-XX:MaxPermSize
- 1.8以后会导致元空间内存溢出，-XX:MaxMetaspaceSize

#### 运行时常量池

##### 定义

​	二进制字节码的组成：类的基本信息、常量池、类的方法定义（包含了虚拟机指令）

​	常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类、方法名、参数类型、字面量等信息。

​	运行时常量池，常量池是存在于.class，字节码文件中的。当该类被加载时，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址。

### StringTable

```java
String s1 = "a";
String s2 = "b";
String s3 = s1 + s2; // new StringBuild().append("a").append("b").toString()    new String("a", "b")
String s4 = "a" + "b"; // javac在编译期间的优化，结果已经在编译器确定为"ab"
String s5 = new String("c") + new String("d"); 
// 串池 ["a", b]  堆 new String("c") new String("d") new String("cd")
String s6 = s5.intern();
// 将这个字符串尝试放入串池，如果有则并不会放入，如果没有则放入串池， 并把串池中的对象返回
```

#### 特性

- 常量池中的字符串仅仅是符号，第一次使用时才变成对象；

- 利用串池机制，来避免重复创建字符串对象；

- 字符串变量拼接原理是StringBuilder（1.8）

- 字符串常量拼接原理是编译器优化

- 可以使用intern方法，主动将串池中还没有的字符串对象放入串池

  - 1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池， 会把串

  池中的对象返回

  - 1.6 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份，

  放入串池， 会把串池中的对象返回

#### StringTable位置

- jdk1.8
  - StringTable放在堆内存中，Minor GC可以回收内存。
- jdk1.8以前
  - StringTable放在永久代中，只有Full GC才可回收内存。

#### StringTable垃圾回收及调优

- 当内存不够时，JVM会对StringTable进行GC

- StringTable由HashTable实现，通过调整HashTable的桶的个数实现调优

  - ```bash
    -XX:StringTableSize=xxxx
    ```

- 若引用的字符串对象过多，可以通过将字符串入池实现调优

  - ``` java
    string.intern()
    ```

### 直接内存

#### 定义

- 常用语NIO操作，用于数据缓冲区   //ByteBuffer.allocateDirect(1024);
- 分配回收成本较高，但读写性能好
- 不会被GC直接回收  // 通过unsafe释放内存，Cleaner是一个虚引用，当java对象被回收时触发直接内存回收。
- IO操作:
  ![avatar](/images/jvm/IO操作.png)
- 直接内存
  ![avatar](/images/jvm/直接内存.png)

## 垃圾回收

### 如何判断对象可以回收

#### 引用计数法

1. 定义：对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1，当引用失效时，引用计数器就减1。只要对象A的计数器为0，则A不再被使用。

2. 存在的问题：

   1. 引用和去引用伴随加法和减法，影响性能

   2. 很难处理循环引用

      ``` mermaid
      graph LR;
      A-->B
      B-->A
      ```

#### 可达性分析

- java虚拟机中的垃圾回收器采用了可达性分析来探索活着的对象
- 扫描堆中对象，看是否能够沿着GC ROOT对象为起点的引用链，找不到则表示可回收
- 可以通过Memary Analysis(MAT)查看GC ROOT

#### 五种引用

![avatar](/images/jvm/五种引用.png)

1. 强引用

   - 只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收

2. 软引用

   - 仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用

   - 对象可以配合引用队列来释放软引用自身

3. 弱引用

   - 仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象
   - 可以配合引用队列来释放弱引用自身

4. 虚引用

   - 必须配合引用队列使用，主要配合 ByteBuffffer 使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存

5. 终结器引用

   - 无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 fifinalize()，第二次 GC 时才能回收被引用对象

### 垃圾回收算法

### 分代垃圾回收

### 垃圾回收器

### 垃圾回收调优


