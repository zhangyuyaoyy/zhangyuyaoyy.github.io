# JVM


本内容根据B站[黑马程序员JVM完整教程](https://www.bilibili.com/video/BV1yE411Z7AP)整理记录。

<!--more-->

## JVM组成

![avator](/images/jvm/JVM组成.png)

## 内存结构

### 程序计数器

程序计数器通过寄存器实现

作用：记录下一条JVM指令执行的地址

特点：

- 线程私有
- 不会线程溢出

### 虚拟机栈

#### 定义

- 栈：线程运行时需要的内存空间。
- 栈帧：方法运行时需要的内存空间。
- 每个栈由多个栈帧组成，对应着每次方法调用时所占用的内存。
- 每个线程只能有一个活动栈帧，对应这当前正在执行的那个方法。

#### 问题辨析

1. GC是否会回收栈内存？
   - GC只会回收堆内存里的对象。
2. 栈内存是否越大越好？
   - 分配太大会导致线程数量减少。
3. 方法内的局部变量是否是线程安全？
   - 如果方法内变量没有逃离方法的作用范围，它就是线程安全的。

#### 栈内存溢出

通过-Xss设置栈内存，默认1024k。

1. 栈帧过多；
2. 栈帧过大。

#### 线程诊断

1. CPU占用过多
   - 定位：
     - top定位进程；
     - ps H -ep pid, tid, %cpu | grep pid 定位线程；
     - jstack pid。
2. 程序长时间没有输出结果
   - jstack pid

### 本地方法栈

#### 定义

- 为本地方法提供内存空间

### 堆

#### 定义

- 通过new关键字创建的对象，都会使用堆内存

#### 堆内存溢出

- 不断创建新对象，同时旧对象一直不被回收。
- 通过-Xms设置堆内存大小

#### 堆内存诊断

1. jps工具

   - 查看当前系统中有哪些java进程

2. jmap工具

   - 查看堆内存占用情况

   - jmap -heap pid

3. jconsole、jvisualjvm

   - 图形化界面，多功能监测工具，可以连续监测。

#### 特点

- 是线程共享的，堆中对象都需要考虑线程安全的问题
- 有垃圾回收机制

### 方法区

![avator](/images/jvm/方法区.png)

#### 方法区内存溢出

- 1.8以前会导致永久代内存溢出，-XX:MaxPermSize
- 1.8以后会导致元空间内存溢出，-XX:MaxMetaspaceSize

#### 运行时常量池

##### 定义

​	二进制字节码的组成：类的基本信息、常量池、类的方法定义（包含了虚拟机指令）

​	常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类、方法名、参数类型、字面量等信息。

​	运行时常量池，常量池是存在于.class，字节码文件中的。当该类被加载时，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址。

#### StringTable

```java
String s1 = "a";
String s2 = "b";
String s3 = s1 + s2; // new StringBuild().append("a").append("b").toString()    new String("a", "b")
String s4 = "a" + "b"; // javac在编译期间的优化，结果已经在编译器确定为"ab"
String s5 = new String("c") + new String("d"); 
// 串池 ["a", b]  堆 new String("c") new String("d") new String("cd")
String s6 = s5.intern();
// 将这个字符串尝试放入串池，如果有则并不会放入，如果没有则放入串池， 并把串池中的对象返回
```

##### 特性

- 常量池中的字符串仅仅是符号，第一次使用时才变成对象；

- 利用串池机制，来避免重复创建字符串对象；

- 字符串变量拼接原理是StringBuilder（1.8）

- 字符串常量拼接原理是编译器优化

- 可以使用intern方法，主动将串池中还没有的字符串对象放入串池

  - 1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池， 会把串

  池中的对象返回

  - 1.6 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份，

  放入串池， 会把串池中的对象返回

##### StringTable位置





​	


