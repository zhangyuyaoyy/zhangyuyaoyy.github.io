[{"categories":["学习笔记"],"content":"本内容根据B站黑马程序员JVM完整教程整理记录。 ","date":"2021-08-26","objectID":"https://zhangyuyaoyy.gitee.io/jvm/:0:0","tags":["java","jvm"],"title":"JVM","uri":"https://zhangyuyaoyy.gitee.io/jvm/"},{"categories":["学习笔记"],"content":"JVM ","date":"2021-08-26","objectID":"https://zhangyuyaoyy.gitee.io/jvm/:1:0","tags":["java","jvm"],"title":"JVM","uri":"https://zhangyuyaoyy.gitee.io/jvm/"},{"categories":["学习笔记"],"content":"内存结构 ","date":"2021-08-26","objectID":"https://zhangyuyaoyy.gitee.io/jvm/:2:0","tags":["java","jvm"],"title":"JVM","uri":"https://zhangyuyaoyy.gitee.io/jvm/"},{"categories":["学习笔记"],"content":"程序计数器 程序计数器通过寄存器实现 作用：记录下一条JVM指令执行的地址 特点： 线程私有 不会线程溢出 ","date":"2021-08-26","objectID":"https://zhangyuyaoyy.gitee.io/jvm/:2:1","tags":["java","jvm"],"title":"JVM","uri":"https://zhangyuyaoyy.gitee.io/jvm/"},{"categories":["学习笔记"],"content":"虚拟机栈 定义 栈：线程运行时需要的内存空间。 栈帧：方法运行时需要的内存空间。 每个栈由多个栈帧组成，对应着每次方法调用时所占用的内存。 每个线程只能有一个活动栈帧，对应这当前正在执行的那个方法。 问题辨析 GC是否会回收栈内存？ GC只会回收堆内存里的对象。 栈内存是否越大越好？ 分配太大会导致线程数量减少。 方法内的局部变量是否是线程安全？ 如果方法内变量没有逃离方法的作用范围，它就是线程安全的。 栈内存溢出 通过-Xss设置栈内存，默认1024k。 栈帧过多； 栈帧过大。 线程诊断 CPU占用过多 定位： top定位进程； ps H -ep pid, tid, %cpu | grep pid 定位线程； jstack pid。 程序长时间没有输出结果 jstack pid ","date":"2021-08-26","objectID":"https://zhangyuyaoyy.gitee.io/jvm/:2:2","tags":["java","jvm"],"title":"JVM","uri":"https://zhangyuyaoyy.gitee.io/jvm/"},{"categories":["学习笔记"],"content":"本地方法栈 定义 为本地方法提供内存空间 ","date":"2021-08-26","objectID":"https://zhangyuyaoyy.gitee.io/jvm/:2:3","tags":["java","jvm"],"title":"JVM","uri":"https://zhangyuyaoyy.gitee.io/jvm/"},{"categories":["学习笔记"],"content":"堆 定义 通过new关键字创建的对象，都会使用堆内存 堆内存溢出 不断创建新对象，同时旧对象一直不被回收。 通过-Xms设置堆内存大小 堆内存诊断 jps工具 查看当前系统中有哪些java进程 jmap工具 查看堆内存占用情况 jmap -heap pid jconsole、jvisualjvm 图形化界面，多功能监测工具，可以连续监测。 特点 是线程共享的，堆中对象都需要考虑线程安全的问题 有垃圾回收机制 ","date":"2021-08-26","objectID":"https://zhangyuyaoyy.gitee.io/jvm/:2:4","tags":["java","jvm"],"title":"JVM","uri":"https://zhangyuyaoyy.gitee.io/jvm/"},{"categories":["学习笔记"],"content":"方法区 方法区内存溢出 1.8以前会导致永久代内存溢出，-XX:MaxPermSize 1.8以后会导致元空间内存溢出，-XX:MaxMetaspaceSize 运行时常量池 定义 ​ 二进制字节码的组成：类的基本信息、常量池、类的方法定义（包含了虚拟机指令） ​ 常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类、方法名、参数类型、字面量等信息。 ​ 运行时常量池，常量池是存在于.class，字节码文件中的。当该类被加载时，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址。 ","date":"2021-08-26","objectID":"https://zhangyuyaoyy.gitee.io/jvm/:2:5","tags":["java","jvm"],"title":"JVM","uri":"https://zhangyuyaoyy.gitee.io/jvm/"},{"categories":["学习笔记"],"content":"StringTable String s1 = \"a\"; String s2 = \"b\"; String s3 = s1 + s2; // new StringBuild().append(\"a\").append(\"b\").toString() new String(\"a\", \"b\") String s4 = \"a\" + \"b\"; // javac在编译期间的优化，结果已经在编译器确定为\"ab\" String s5 = new String(\"c\") + new String(\"d\"); // 串池 [\"a\", b] 堆 new String(\"c\") new String(\"d\") new String(\"cd\") String s6 = s5.intern(); // 将这个字符串尝试放入串池，如果有则并不会放入，如果没有则放入串池， 并把串池中的对象返回 特性 常量池中的字符串仅仅是符号，第一次使用时才变成对象； 利用串池机制，来避免重复创建字符串对象； 字符串变量拼接原理是StringBuilder（1.8） 字符串常量拼接原理是编译器优化 可以使用intern方法，主动将串池中还没有的字符串对象放入串池 1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池， 会把串 池中的对象返回 1.6 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份， 放入串池， 会把串池中的对象返回 StringTable位置 jdk1.8 StringTable放在堆内存中，Minor GC可以回收内存。 jdk1.8以前 StringTable放在永久代中，只有Full GC才可回收内存。 StringTable垃圾回收及调优 当内存不够时，JVM会对StringTable进行GC StringTable由HashTable实现，通过调整HashTable的桶的个数实现调优 -XX:StringTableSize=xxxx 若引用的字符串对象过多，可以通过将字符串入池实现调优 string.intern() ","date":"2021-08-26","objectID":"https://zhangyuyaoyy.gitee.io/jvm/:2:6","tags":["java","jvm"],"title":"JVM","uri":"https://zhangyuyaoyy.gitee.io/jvm/"},{"categories":["学习笔记"],"content":"直接内存 定义 常用语NIO操作，用于数据缓冲区 //ByteBuffer.allocateDirect(1024); 分配回收成本较高，但读写性能好 不会被GC直接回收 // 通过unsafe释放内存，Cleaner是一个虚引用，当java对象被回收时触发直接内存回收。 IO操作: 直接内存 ","date":"2021-08-26","objectID":"https://zhangyuyaoyy.gitee.io/jvm/:2:7","tags":["java","jvm"],"title":"JVM","uri":"https://zhangyuyaoyy.gitee.io/jvm/"},{"categories":["学习笔记"],"content":"垃圾回收 ","date":"2021-08-26","objectID":"https://zhangyuyaoyy.gitee.io/jvm/:3:0","tags":["java","jvm"],"title":"JVM","uri":"https://zhangyuyaoyy.gitee.io/jvm/"},{"categories":["学习笔记"],"content":"如何判断对象可以回收 引用计数法 定义：对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1，当引用失效时，引用计数器就减1。只要对象A的计数器为0，则A不再被使用。 存在的问题： 引用和去引用伴随加法和减法，影响性能 很难处理循环引用 graph LR; A--\u003eB B--\u003eA 可达性分析 java虚拟机中的垃圾回收器采用了可达性分析来探索活着的对象 扫描堆中对象，看是否能够沿着GC ROOT对象为起点的引用链，找不到则表示可回收 可以通过Memary Analysis(MAT)查看GC ROOT 五种引用 强引用 只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收 软引用 仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用 对象可以配合引用队列来释放软引用自身 弱引用 仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象 可以配合引用队列来释放弱引用自身 虚引用 必须配合引用队列使用，主要配合 ByteBuffffer 使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存 终结器引用 无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 fifinalize()，第二次 GC 时才能回收被引用对象 ","date":"2021-08-26","objectID":"https://zhangyuyaoyy.gitee.io/jvm/:3:1","tags":["java","jvm"],"title":"JVM","uri":"https://zhangyuyaoyy.gitee.io/jvm/"},{"categories":["学习笔记"],"content":"垃圾回收算法 标记清除 ​ 标记-清除算法是现代垃圾回收算法的思想基础。标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。一种可行的实现是，在标记阶段，首先通过根节点，标记所有从根节点可达对象（可达性分析）。未被标记的对象就是未被引用的垃圾对象。然后再清除阶段，清除所有未被标记的对象（记录地址的起始位置，不会实际清空字节）。 ​ 优点：速度快 ​ 缺点：会产生内存碎片 标记整理(标记压缩) ​ 标记压缩算法适合于存活对象较多的场合，如老年代。它在标记-清除算法上做了一定的优化。和标记-清除算法一样，标记-压缩算法也首先需要从根节点开始，对所有可达对象做一次标记。但之后，它并不简单的清理未标记对象，而是将所有存活对象压缩到内存的一端。之后清理边界外所有的空间。 ​ 优点：不会产生内存碎片 ​ 缺点：速度慢 复制算法 ​ 与标记-清除算法相比，复制算法是一个相对高效的回收方法。不适用于存活对象较多的场合。将原有的内存空分为两块，每次只是用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中。之后清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。 ​ 优点：不会有内存碎片 ​ 缺点：需要两倍的内存空间 ","date":"2021-08-26","objectID":"https://zhangyuyaoyy.gitee.io/jvm/:3:2","tags":["java","jvm"],"title":"JVM","uri":"https://zhangyuyaoyy.gitee.io/jvm/"},{"categories":["学习笔记"],"content":"分代回收 定义 对象首先分配在伊甸园区域 新生代空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的 对象年龄加 1并且交换 from to minor gc 会引发 stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行 当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit） 当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 full gc，STW的时间更长 相关参数 注释 参数 堆初始大小 -Xms 堆最大大小 -Xmx 或 -XX:MaxHeapSize=size 新生代大小 -Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size ) 幸存区比例（动态） -XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy 幸存区比例 -XX:SurvivorRatio=ratio 晋升阈值 -XX:MaxTenuringThreshold=threshold 晋升详情 -XX:+PrintTenuringDistribution GC详情 -XX:+PrintGCDetails -verbose:gc FullGC 前 MinorGC -XX:+ScavengeBeforeFullGC ","date":"2021-08-26","objectID":"https://zhangyuyaoyy.gitee.io/jvm/:3:3","tags":["java","jvm"],"title":"JVM","uri":"https://zhangyuyaoyy.gitee.io/jvm/"},{"categories":["学习笔记"],"content":"垃圾回收器 ","date":"2021-08-26","objectID":"https://zhangyuyaoyy.gitee.io/jvm/:3:4","tags":["java","jvm"],"title":"JVM","uri":"https://zhangyuyaoyy.gitee.io/jvm/"},{"categories":["学习笔记"],"content":"垃圾回收调优","date":"2021-08-26","objectID":"https://zhangyuyaoyy.gitee.io/jvm/:3:5","tags":["java","jvm"],"title":"JVM","uri":"https://zhangyuyaoyy.gitee.io/jvm/"}]